# 用户行为习惯预测

### 基本假设
* 事物状态(或者说事件)对应于与完备的矢量空间中的一个矢量，这个矢量空间为状态空间

* 智能家居系统的状态空间可以由其组成的事物之间的状态空间进行笛卡尔积得到

* 对于同一个状态空间中的两个状态矢量a,b而言，若两个状态之间所表示的现实含义越相同，其度量值g(a,b) = a*b = c 数值越大，c为实数

* 对于一个现实事物，其有多个属性，每个属性的状态对于与状态空间中的一个矢量en，那么事物的状态a由这些属性的状态进行叠加，这些属性的状态矢量是正交归一，即a = c1*e1+c2*e2+...+cn*en，其中cn为(0,1)之间的实数，cn = g(en,a)表示事物的属性n对于事物的重要程度


### 特征提取规则
    现实生活中两个状态如果相同，那么他们的相似度度量值就越大，反之越小，比如说对于实数的向量化处理，我们需要保留的不仅经只是数本身的信息，还有数和数之间的关系，比如说19和20，他们本身只是冷冰冰的数字，区分它们的方式有很多，比如说看个位和十位，他们是不同的，但是对于现实而言，这两个数字足够接近，而根据公设3，这两个向量化之后的相似度应该是足够高的，无法直接通过向量化个位和十位来构建向量

### 数据包格式
* device_name:设备名，唯一的id，也是下位机判断该消息是否是给自己的
* control_variable:下位机所需要的控制的环境变量
* room:下位机所处的房间编号

### 设备属性
* device_name:设备名，同时也是设备通信的用来确认该消息是否是发送给自己的判断依据
* device_type:设备控制类型
* date:消息的年月日
* time:24小时，一天之内的具体时间
* state:设备所绑定的状态值

### 特征
brain通过上一条操作记录预测用户下一条可能的操作记录，同时发送给智能手机

### 注意力机制
    数学上面加权求和的思想，首先明确，我们的状态是由多个状态进行加权求和得到的，而每个权值的大小，意味着当前状态对最终状态的贡献程度，所以通过调整每个状态对应的权值，使得模型对于某个状态的变化更加敏感

    所谓的注意力呢，就是说一个状态，可能是由无数个状态进行叠加的，但是这些叠加的状态，有的改变对现有的总状态的改变没有什么太大的影响，而有的轻微的变化则会极大的影响总状态，我们就说这个状态对于总状态来说是重要的，其相应的权值也就越高，而不重要的状态其权值越小

    比如著名的Transformer中，输入一个矢量x，其会通过三个算符QKV变成对应的矢量，而QKV可以用矩阵表示，可以用神经网络进行训练，而我们将Q和K的内积结果作为一个权值，而我们的系统的总状态是以V为基底进行加权求和的结果X'，而我们希望的是X'和X极度相似，但是X'比X来说更加具备全局的信息

    其是接近我们公设4的一个方法

## 智能家居神经网络模型

网络模型就是通过当前的操作记录去预测下一条操作记录

* 编码层:用户的操作记录进行向量化处理，我们使用到的是sine和cosine两个函数
    * 设备状态描述: 首先是是对用户设备的一个向量化，我们的设备是通过设备属性进行抽象，但是这些设备属性有些事重要的，有些又是不重要的，根据公设4，我们可以认为说一个设备的状态可以由一个矢量表示，而这个设备的状态矢量又是属性状态矢量的加权求和，权值越大的属性，他的状态对设备状态的影响是比其他属性的状态的影响来得大，所以设备向量化的步骤是先把设备的属性状态进行向量化，最后通过属性状态矢量的加权求和得到我们的总设备状态矢量

    * 时间状态描述:时间是智能家居系统的重要参数，它可以用来描述智能家居系统状态的演化，而我们的智能家居操作模型一定是一个显含时的映射，我们不能通过简单的(年，月，日，时，分，秒)来对我们的时间进行向量化，因为根据公设3，我们眼中的(2023,12,31,23,59)和(2024,1,1,0,0)的世界面是无限接近的，但是再计算机眼中，他们作为向量来说两个向量的距离是十分遥远的，所以我们可以使用“周而复始”的概念，对一年之中的时间进行一个向量化，但是显然我们的刻度不能精确到一年当中的某一分钟，如果精确到一年中的某一分钟，那么数据集的区别将会是十分微小，甚至难以区分和定量描述，我们可以使用公设2的思想，把一年当中的时间看成一年当中的某一天的向量化以及一天当中的某一天的向量化的笛卡尔积

    * 控制变量描述:首先我们的控制变量一般有(变量，变量值),要这三个元素可以确定要给控制变量，而我们往往需要去预测变量和变量值，一个变量的状态是由它的变量名和变量类型进行确定的，其变量类型的状态显然是比变量名来得重要的，可以利用公设4的方法对变量进行向量化，而变量值，因为float类型的数据由最大和最小的限制，我们依旧使用归一化来进行预测

* 输入层:将编码后的特征矢量输入到神经网络中

* 注意力层:接受输入层传递过来的矢量，同时进行计算，让计算机可以学习到当前记录的状态和下一条记录的状态直接的变化因素是什么

* 残差连接层:作为编码器层的输出，使用残差连接可以防止过拟合

* 注意力层:接受编码器层的输出

* 输出层:输出下一个操作记录的状态矢量

## 工作
要让神经网络直接去预测用户对于每个智能家居的工作，这个实话应用不是很好。我们可以采用半自动的工作模式来，就是说将智能家居的系统状态划分为多个场景，每个场景里面的智能设备的工作情况由人为手动创建，或者是去让机器去学习在这个场景下该怎么工作。就是将原先的一个大的神经网络变成多个神经网络分别控制。

#### 场景划分
* wake_up:起床场景
* grooming:洗漱场景
* morning_dining:早餐场景
* away:离家场景
* homecoming:回家场景
* dining:晚餐场景
* movie:观影场景
* sleep:睡眠场景

当服务器计算出当前可能处于的场景状态的时候，就会把场景的结果发送给所有的智能家居设备，智能家居设备收到这个状态矢量的时候，就会计算出当前可能处于的状态，而这个计算过程又是一个神经网络，一个智能家居设备对应于一个神经网络

#### 设备在场景下的工作
首先，设备必须以人为本，但是又不能什么事情都要询问主人。

* 思路一:计算设备在场景下的状态是什么样的，神经网络需要预测当前设备的所有属性在这个场景下的状态

* 思路二:计算设备在当前场景下可能要具体执行的一步操作，只去预测一条指令，一个属性的状态

* 思路三:首先计算设备在当前场景下的开关，如果结果是关闭，就不在进行下一步计算，如果计算结果是开的化，将会对设备的每个属性的状态进行预测，属性的预测是一步一步进行的，比如说空调，预测为开还是关以后，去预测空调的温度，

